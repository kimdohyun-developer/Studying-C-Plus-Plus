#include<iostream>
#include<string>
using namespace std;

//class의 선언
//클래스란 객체 지향 프로그래밍의 특징중 하나인 추상화(abstraction)를 사용자 정의 타입으로 구현한 것이다.
//문법
/*
class 클래스이름
{

접근제어지시자1:

    멤버변수1의타입 멤버변수1의이름;

    멤버변수2의타입 멤버변수2의이름;

    ...

    멤버함수1의 원형

    멤버함수2의 원형

    ...
};
*/

//멤버 함수의 정의
//클래스에서 멤버 함수를 정의하는 방법은 일반 함수의 정의와 크게 다르지 않다.
//C++에서는 멤버 함수를 클래스의 선언안이나 밖에서 모두 정의할 수 있도록 허용한다.

//클래스의 선언밖에서 멤버 함수를 정의할 때에는 범위 지정 연산자(::)를 사용하여 해당 함수가 어느 클래스에 속하는지를 명시해야한다.
//문법
//반환타입 클래스이름::멤버함수이름(매개변수목록) { 함수의 몸체; }
//예
//void Car::Move(int engine) { this.engine = engine; }

//만약 멤버 함수가 클래스의 선언 안에서 정의되면, 이 함수는 인라인 함수로 처리되어 위와 같이 범위 지정 연산자를 사용하여 소속 클래스를 명시할 필요가 없게 된다.
//또한, 클래스 선언 밖에서 정의된 멤버함수도 inline키워드를 사용하여 인라인 함수로 처리할 수 있다.

//하나의 클래스에서 생성된 인스턴스는 각각 독립된 메모리 공간에 저장된 자신만의 멤버변수를 가지지만 , 멤버 함수는 모든 인스턴스가 공유하게 된다. 
//Plus++
//멤버 함수는 클래스의 선언이나 밖에서 모두 정의할 수 있지만, 클래스가 일단 선언된 후에 멤버함수를 추가할 수는 없다.

//객체생성(create instance)
//문법
//(클래스이름) (변수이름);
//다른 언어와는 조금 다른 모습을 보인다.
 
//예제

class Car
{
	private:int carId; //멤버 변수 
	private:string carName; //멤버 변수 
	//이런식으로 private를 붙이면 클래스 밖에서는 멤버변수에 접근할 수 없으므로 정보보호에 좋음.
	 
	public: void getCar(int a,string b)
	{
		carId = a;
		carName=b;
	} 
	public:void carInfo() //멤버 함수 
	{
		cout<<"차량번호: "<<carId<<endl;
		cout<<"차량이름: "<<carName;
	}
	
 };
int main(void)
{
	Car cc; //C++에서는 이런식으로 객체를 생성한다. 
	cc.getCar(122121, "그랜저");
	cc.carInfo();
	return 0; 
}
